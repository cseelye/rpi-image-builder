#!/bin/bash
set -euo pipefail

BUILDER_IMAGE=$(cat .image-name)

# Detect if qemu is installed on the host
if [[ -z ${HOST_QEMU:-} ]]; then
    which qemu-system-aarch64 &>/dev/null && HOST_QEMU=1 || HOST_QEMU=0;
fi
export HOST_QEMU

# Build the helper image
docker image build --rm --force-rm --tag ${BUILDER_IMAGE} image-builder

# Get a fully resolved path to a temp dir, to work around the docker file sharing restrictions in macOS
temp_dir=$(mktemp -d)
temp_dir=$(cd "${temp_dir}"; pwd -P)
trap 'rm -rf "${temp_dir}"' EXIT ERR INT TERM HUP

envfile=$(mktemp "${temp_dir}"/.envfile.XXXXXX)
export -p | grep -v "DISPLAY\|HOME\|HOST=\|LS_COLORS\|PATH\|PERL\|PWD\|SHELL\|SHLVL\|SSH\|TERM\|TMPDIR\|USER=" > ${envfile}

docker container run --rm -it --privileged \
                     --name rpi-boot-image-$(uuidgen) \
                     --mount type=bind,src="${envfile}",dst=/tmp/envfile \
                     --mount type=bind,src="${temp_dir}",dst=/work \
                     --mount type=bind,src=$(pwd),dst=/builder \
                     --workdir /builder \
                     --publish 127.0.0.1:5522:5522 \
                     ${BUILDER_IMAGE} \
                     image-builder/run-image-qemu "${1}"

if [[ ${HOST_QEMU} -eq 1 ]]; then
    # Import the config created in the container and run it
    eval "$(cat ${temp_dir}/qemu_config)"
    pidfile="$(mktemp)"
    image_path="${temp_dir}"/"${image_file}"
    kernel_file="${temp_dir}"/boot/vmlinuz
    initrd_file="${temp_dir}"/boot/initrd.img

    echo ">>> Starting Pi (native qemu)"
    eval "${qemu_cmd}"
fi
