#!/bin/bash
set -euo pipefail

COMPRESS=${COMPRESS:-0}
BASE_IMAGE_URL=${BASE_IMAGE_URL:-http://cdimage.ubuntu.com/ubuntu/releases/18.04/release/ubuntu-18.04.4-preinstalled-server-arm64+raspi3.img.xz}
BASE_IMAGE=${BASE_IMAGE:-${BASE_IMAGE_URL##*/}}
FINAL_IMAGE=${FINAL_IMAGE:-custom-rpi.img}
DOCKER=${DOCKER:-0}
DOCKER_IMAGE=${DOCKER_IMAGE:-custom-rpi-image}
ARTIFACT_DIR=${ARTIFACT_DIR:-artifacts}
WORK_DIR=${WORK_DIR:-work}
CHROOT=${CHROOT:-${WORK_DIR}/chroot}
FREE_SPACE=${FREE_SPACE:-1024}

[[ "$UID" -eq 0 ]] || exec sudo "$0" "$@"

# Import host environment
if [[ -e /tmp/envfile ]]; then
    source /tmp/envfile
fi


function unmount_special()
{
    for mnt in ${CHROOT}/dev ${CHROOT}/sys ${CHROOT}/proc; do
        while mountpoint --quiet ${mnt} && ! umount --recursive ${mnt}; do
            sleep 1
        done
    done
}
function restore_chroot_resolver()
{
    # Fix resolv.conf in the chroot
    if [[ -e "${CHROOT}"/etc ]]; then
        (
            cd "${CHROOT}"/etc
            rm --one-file-system --force resolv.conf
            ln -s ../run/systemd/resolve/stub-resolv.conf resolv.conf
        )
    fi
}
function unmount_chroot()
{
    restore_chroot_resolver
    sync
    unmount_special
    for mnt in ${CHROOT}/boot/firmware ${CHROOT}; do
        while mountpoint --quiet ${mnt} && ! umount --recursive ${mnt}; do
            sleep 1
        done
    done
}

function unmount_image()
{
    lodev=$(losetup --associated "${WORK_DIR}"/"${working_image}" --noheadings --output NAME)
    if [[ -n "${lodev}" ]]; then
         losetup --detach ${lodev}
    fi
}

function cleanup()
{
    echo ">>> Cleanup"
    set +eu

    unmount_chroot
    unmount_image

    rm --one-file-system --force --recursive "${WORK_DIR}"
    exit
}


mkdir --parents "${ARTIFACT_DIR}"
mkdir --parents "${WORK_DIR}"
mkdir --parents "${CHROOT}"
mkdir --parents /tmp

if [[ -e "${BASE_IMAGE}" ]]; then
    mv "${BASE_IMAGE}" artifacts/
fi

if [[ ! -e "${ARTIFACT_DIR}"/"${BASE_IMAGE}" ]]; then
    echo ">>> Downloading base image"
    # Download to /tmp and then move into place, in case we get interrupted in the middle we don't want to leave an invalid image
    curl --insecure --location ${BASE_IMAGE_URL} --output /tmp/"${BASE_IMAGE}"
    mv /tmp/"${BASE_IMAGE}" "${ARTIFACT_DIR}"/"${BASE_IMAGE}"
fi

trap cleanup EXIT INT TERM HUP

stock_image="${BASE_IMAGE%.*}"
if [[ ! -e "${ARTIFACT_DIR}"/"${stock_image}" ]]; then
    echo ">>> Decompressing base image"
    # Decompress in /tmp and then move into place, in case we get interrupted in the middle we don't want to leave an invalid image
    nice --adjustment 19 pixz -d -k "${ARTIFACT_DIR}"/"${BASE_IMAGE}" /tmp/"${stock_image}"
    mv /tmp/"${stock_image}" "${ARTIFACT_DIR}"/"${stock_image}"
fi

# Copy the base image so we leave the base unmodified and only work from our own new image
echo ">>> Creating new image"
working_image=working.img
cp "${ARTIFACT_DIR}"/"${stock_image}" "${WORK_DIR}"/"${working_image}"

# The image has very little free space and must be expanded to be able to install/configure
# When the pi first boots it automatically expands the partititon to the full size of the SD card, this does not change that
# Expand the size of the image here, then expand the partition and filesystem after mounting the image
echo ">>> Increasing free space in image by ${FREE_SPACE} MB"
dd if=/dev/zero bs=1M count=${FREE_SPACE}ÃŸ >> "${WORK_DIR}"/"${working_image}"
parted --script "${WORK_DIR}"/"${working_image}" resizepart 2 -- -1s

echo ">>> Mounting image"
if ! losetup --all --output NAME,BACK-FILE | grep -q "${working_image}"; then
    losetup --find --partscan "${WORK_DIR}"/"${working_image}"
fi
lodev=$(losetup --associated "${WORK_DIR}"/"${working_image}" --noheadings --output NAME)

# Workaround udev not existing in container, so we need to create the partition devices manually
major_min=$(lsblk --noheadings --output NAME,MAJ:MIN  --list ${lodev} | grep p1 | awk '{print $2}' | tr ':' ' ')
mknod ${lodev}p1 b ${major_min}
major_min=$(lsblk --noheadings --output NAME,MAJ:MIN  --list ${lodev} | grep p2 | awk '{print $2}' | tr ':' ' ')
mknod ${lodev}p2 b ${major_min}

echo ">>> Expanding filesystem"
parted --script ${lodev} resizepart 2 100%
e2fsck -f ${lodev}p2
resize2fs ${lodev}p2

echo ">>> Preparing chroot"
mount --options rw ${lodev}p2 "${CHROOT}"
mkdir --parents "${CHROOT}"/boot/firmware
mount --options rw ${lodev}p1 "${CHROOT}"/boot/firmware

mount --types proc proc ${CHROOT}/proc
mount --rbind /dev ${CHROOT}/dev
mount --rbind /sys ${CHROOT}/sys

# Use the host resolver config so the chroot has connectivity
rm --one-file-system --force "${CHROOT}"/etc/resolv.conf
cp --force /etc/resolv.conf ${CHROOT}/etc/resolv.conf

# Debug - jump into the chroot to poke around
# chroot ${CHROOT} bash
# exit

# Copy the files from the overlay directory into the corresponding location in the chroot
echo ">>> Applying overlay"
( set -x; rsync --verbose --archive --one-file-system --chown root:root --exclude README.md overlay/ ${CHROOT} )

# Copy the config-hooks into the chroot and then run each one
rsync --quiet --archive --copy-links --one-file-system config-hooks ${CHROOT}
for hook in $(find ${CHROOT}/config-hooks -maxdepth 1 -executable -type f -o -type l | sort); do
    echo ">>> Executing config hook $(basename ${hook})"
    (
        chroot ${CHROOT} config-hooks/$(basename ${hook})
    ) 2>&1 | sed 's/^/    /'
done
rm --one-file-system --force --recursive ${CHROOT}/config-hooks
sync
sleep 1
echo ">>> Finished configuring image"

restore_chroot_resolver
unmount_special

if [[ ${DOCKER} -eq 1 ]]; then
    echo ">>> Importing docker image"
    tar --directory ${CHROOT} --create . | docker image import - ${DOCKER_IMAGE}
fi

unmount_chroot
unmount_image

if [[ ${COMPRESS} -eq 1 ]]; then
    echo ">>> Compressing image"
    nice --adjustment 19 pixz -c -8 "${WORK_DIR}"/"${working_image}"
    mv --force "${WORK_DIR}"/"${working_image}"* "${ARTIFACT_DIR}"/"${FINAL_IMAGE}".xz
else
    mv --force "${WORK_DIR}"/"${working_image}" "${ARTIFACT_DIR}"/"${FINAL_IMAGE}"
fi
echo
echo "Created image"
ls -lv --human-readable "${ARTIFACT_DIR}"/"${FINAL_IMAGE}"
echo
